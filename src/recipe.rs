pub mod search_algorithms;

use enumset::EnumSet;

use crate::{
    effect::{self, Effect},
    expenses::Expenses,
    ingredients::{Base, Intermediate},
};

/// A recipe for a drug.
#[derive(Clone, Debug)]
pub struct Recipe {
    base: Base,
    intermediates: Vec<Intermediate>,
}

impl Default for Recipe {
    fn default() -> Self {
        Recipe {
            base: Base::OGKush,
            intermediates: Vec::default(),
        }
    }
}

#[expect(clippy::to_string_trait_impl)]
impl ToString for Recipe {
    fn to_string(&self) -> String {
        let mut s = String::new();
        s.push_str("Base:\n");
        s.push_str(format!("  {}\n\n", self.base).as_str());

        let mut i = 1;
        s.push_str("Steps:\n");
        for ingredient in &self.intermediates {
            s.push_str(
                format!(
                    "  {i}. Add {} to the mixture and stir.\n",
                    ingredient.name()
                )
                .as_str(),
            );
            i += 1;
        }
        s.push_str(format!("  {}. ???\n  {}. Profit!\n\n", i, i + 1).as_str());

        let mut effects: Vec<_> = self.calculate_effects().into_iter().collect();
        effects.sort_by_key(|e| e.to_string());
        s.push_str("Effects:\n");
        effects
            .iter()
            .for_each(|e| s.push_str(format!("  - {}\n", e).as_str()));

        s.push_str(format!("\nAddictiveness:\n  {:.2}\n", self.addictiveness()).as_str());

        s
    }
}

#[allow(dead_code)]
impl Recipe {
    /// Creates a `Recipe` with the given `Base`.
    pub fn with_base(base: Base) -> Self {
        Self {
            base,
            intermediates: Vec::new(),
        }
    }

    /// Adds an ingredient to the end of this `Recipe` and returns the result.  
    /// Helper function to easily build a `Recipe`.
    pub fn add_intermediate(mut self, intermediate: Intermediate) -> Self {
        self.intermediates.push(intermediate);

        self
    }

    /// Returns the base ingredient of this `Recipe`.
    pub fn base(&self) -> Base {
        self.base
    }

    /// Returns a `Vec` of the `Recipe`'s ingredients.
    pub fn intermediates(&self) -> &Vec<Intermediate> {
        &self.intermediates
    }

    /// Calculates the effects of this `Recipe`.
    pub fn calculate_effects(&self) -> EnumSet<Effect> {
        let mut set = EnumSet::new();
        if let Some(e) = self.base.effect() {
            set.insert(e);
        }

        for i in &self.intermediates {
            i.apply_to_effect_set(&mut set);
        }

        set
    }

    /// Calculates the cost to produce one unit of this `Recipe` as a negative f32.
    pub fn production_cost(&self, expenses: Expenses) -> f32 {
        self.base.production_cost(expenses)
            + self
                .intermediates
                .iter()
                .map(|x| x.purchase_price())
                .sum::<f32>()
    }

    /// Calculates the selling price of one unit of this `Recipe`.
    pub fn sell_price(&self) -> f32 {
        self.base.sell_price() * (1.0 + effect::get_total_price_modifier(self.calculate_effects()))
    }

    /// Calculates the profit generated by producing and selling one unit of this `Recipe`.
    pub fn profit(&self, expenses: Expenses) -> f32 {
        self.sell_price() + self.production_cost(expenses)
    }

    /// Calculates the profit margin of this `Recipe`.
    pub fn profit_margin(&self, expenses: Expenses) -> f32 {
        (self.profit(expenses)) / self.sell_price()
    }

    /// Calculates the addictiveness of this `Recipe`, clamped between `f32::MIN_POSITIVE` and `1.0``.
    pub fn addictiveness(&self) -> f32 {
        (self.base.addictiveness()
            + self
                .calculate_effects()
                .iter()
                .map(|e| e.addictiveness())
                .sum::<f32>())
        .clamp(f32::MIN_POSITIVE, 1.0)
    }
}
